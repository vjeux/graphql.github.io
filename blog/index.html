<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Blog | GraphQL</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="GraphQL | A data query language and runtime"><meta property="og:type" content="website"><meta property="og:url" content="http://graphql.org/"><meta property="og:description" content="A data query language and runtime"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/graphql.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="40" height="40">GraphQL</a><ul class="nav-site"><li><a href="/docs/getting-started/" class="">Docs</a></li><li><a href="/blog/" class="active">Blog</a></li><li><a href="/help/" class="">Help</a></li><li><a href="/code/" class="">Code</a></li><li><a href="http://facebook.github.io/graphql/" target="_blank" class="">Spec</a></li></ul></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Recent Posts</h3><ul><li><a href="/blog/subscriptions-in-graphql-and-relay/">Subscriptions in GraphQL and Relay</a></li><li><a href="/blog/graphql-a-query-language/">GraphQL: A data query language</a></li></ul></div></div><div class="inner-content"><h1><a href="/blog/subscriptions-in-graphql-and-relay/">Subscriptions in GraphQL and Relay</a></h1><p>10/16/2015 by Dan Schafer and Laney Kuenzel</p><hr><div><p>When we announced and open-sourced GraphQL and Relay this year, we described how they can be used to perform reads with queries, and to perform writes with mutations. However, oftentimes clients want to get pushed updates from the server when data they care about changes. To support that, we’ve introduced a third operation into the GraphQL specification: subscription.</p><h2><a class="anchor" name="event-based-subscriptions"></a>Event-based subscriptions <a class="hash-link" href="/blog/subscriptions-in-graphql-and-relay/#event-based-subscriptions">#</a></h2><p>The approach that we’ve taken to subscriptions parallels that of mutations; just as the list of mutations that the server supports describes all of the actions that a client can take, the list of subscriptions that the server supports describes all of the events that it can subscribe to. Just as a client can tell the server what data to refetch after it performs a mutation with a GraphQL selection, the client can tell the server what data it wants to be pushed with the subscription with a GraphQL selection.</p><p>For example, in the Facebook schema, we have a mutation field named <code>storyLike</code>, that clients can use to like a post. The client might want to refetch the like count, as well as the like sentence (“Dan and 3 others like this”. We do this translation on the server because of the complexity of that translation in various languages). To do so, they would issue the following mutation:</p><pre class="prism language-javascript">
mutation <span class="token function">StoryLikeMutation</span><span class="token punctuation">(</span>$input<span class="token punctuation">:</span> StoryLikeInput<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">storyLike</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> $input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    story <span class="token punctuation">{</span>
      likers <span class="token punctuation">{</span> count <span class="token punctuation">}</span>
      likeSentence <span class="token punctuation">{</span> text <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>But when you’re looking at a post, you also want to get pushed an update whenever someone else likes the post! That’s where subscriptions come in; the Facebook schema has a subscription field named <code>storyLikeSubscribe</code> that allows the client to get pushed data anytime someone likes or unlikes that story! The client would create a subscription like this:</p><pre class="prism language-javascript">
subscription <span class="token function">StoryLikeSubscription</span><span class="token punctuation">(</span>$input<span class="token punctuation">:</span> StoryLikeSubscribeInput<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">storyLikeSubscribe</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> $input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    story <span class="token punctuation">{</span>
      likers <span class="token punctuation">{</span> count <span class="token punctuation">}</span>
      likeSentence <span class="token punctuation">{</span> text <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>The client would then send this subscription to the server, along with the value for the <code>$input</code> variable, which would contain information like the story ID to which we are subscribing:</p><pre class="prism language-javascript">
input StoryLikeSubscribeInput <span class="token punctuation">{</span>
  storyId<span class="token punctuation">:</span> string
  clientSubscriptionId<span class="token punctuation">:</span> string
<span class="token punctuation">}</span></pre><p>At Facebook, we send this query to the server at build time to generate a unique ID for it, then subscribe to a special MQTT topic with the subscription ID in it, but many different subscription mechanisms could be used here.</p><p>On the server, we then trigger this subscription every time someone likes a post. If all of our clients were using GraphQL, we could put this hook in the GraphQL mutation; since we have non-GraphQL clients as well, we put the hook in a layer below the GraphQL mutation to ensure it always fires.</p><h2><a class="anchor" name="why-not-live-queries"></a>Why not Live Queries? <a class="hash-link" href="/blog/subscriptions-in-graphql-and-relay/#why-not-live-queries">#</a></h2><p>Notably, this approach requires the client to subscribe to events that it cares about. Another approach is to have the client subscribe to a query, and ask for updates every time the result of that query changes. Why didn’t we take that approach?</p><p>Let’s look back at the data we wanted to refetch for the story:</p><pre class="prism language-javascript">
fragment StoryLikeData on Story <span class="token punctuation">{</span>
  story <span class="token punctuation">{</span>
    likers <span class="token punctuation">{</span> count <span class="token punctuation">}</span>
    likeSentence <span class="token punctuation">{</span> text <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>What events could trigger that a change to the data fetched in that fragment?</p><ul><li>Someone likes the post.</li><li>Someone unlikes the post.</li><li>Someone who had liked the post deactivates their account (changes the like count down one, changes the like sentence to decrement the translated count).</li><li>Someone who had liked the post reactivates their account (changes the like count up one, changes the like sentence to increment the translated count).</li><li>Someone who had liked the post blocks you (cannot show them in the like sentence).</li><li>Someone who had liked the post changes their name (need to update the text of the like sentence).</li><li>Our internal ranking model for the ordering of names in the like sentence updates, and we should be listing a different person first (want to update the text of the like sentence).</li></ul><p>And that’s just the tip of the iceberg in terms of events; each of those events also becomes tricky when there are thousands of people subscribed, and millions of people who liked the post. Implementing live queries for this set of data proved to be immensely complicated.</p><p>When building event-based subscriptions, the problem of determining what should trigger an event is easy, since the event defines that explicitly. It also proved fairly straight-forward to implement atop existing message queue systems. For live queries, though, this appeared much harder. The value of our fields is determined by the result of their resolve function, and figuring out all of the things that could alter the result of that function was difficult. We could in theory have polled on the server to implement this, but that had efficiency and timeliness issues. Based on this, we decided to invest in the event-based subscription approach.</p><h2><a class="anchor" name="what-s-next"></a>What’s next? <a class="hash-link" href="/blog/subscriptions-in-graphql-and-relay/#what-s-next">#</a></h2><p>We’re actively building out the event-based subscription approach described above. We’ve built out live liking and commenting features on our iOS and Android apps using that approach, and are continuing to flush out its functionality and API. While its current implementation at Facebook is coupled to Facebook’s infrastructure, we’re certainly looking forward to open sourcing our progress here as soon as we can.</p><p>Because our backend and schema don’t offer easy support for live queries, we don’t have any plans to develop them at Facebook. At the same time, it’s clear that there are backends and schemas for which live queries are feasible, and that they offer a lot of value in those situations. The discussion in the community on this topic has been fantastic, and we’re excited to see what kind of live query proposals emerge from it!</p><p>Subscriptions create a ton of possibilities for creating truly dynamic applications. We’re excited to continue developing GraphQL and Relay with the help of the community to enable these possibilities.</p></div></div><div class="inner-content"><h1><a href="/blog/graphql-a-query-language/">GraphQL: A data query language</a></h1><p>9/14/2015 by Lee Byron</p><hr><div><div>

</div><p>When we built Facebook&#x27;s mobile applications, we needed a data-fetching API powerful enough to describe all of Facebook, yet simple and easy to learn so product developers can focus on building things quickly. We developed GraphQL three years ago to fill this need. Today it powers hundreds of billions of API calls a day. This year we&#x27;ve begun the process of open-sourcing GraphQL by drafting a specification, releasing a reference implementation, and forming a community around it here at <a href="http://graphql.org/" target="_blank">graphql.org</a>.</p><h2><a class="anchor" name="why-graphql"></a>Why GraphQL? <a class="hash-link" href="/blog/graphql-a-query-language/#why-graphql">#</a></h2><p>Back in 2012, we began an effort to rebuild Facebook&#x27;s native mobile applications.</p><p>At the time, our iOS and Android apps were thin wrappers around views of our mobile website. While this brought us close to a platonic ideal of the &quot;write one, run anywhere&quot; mobile application, in practice it pushed our mobile-webview apps beyond their limits. As Facebook&#x27;s mobile apps became more complex, they suffered poor performance and frequently crashed.</p><p>As we transitioned to natively implemented models and views, we found ourselves for the first time needing an API data version of News Feed — which up until that point had only been delivered as HTML. We evaluated our options for delivering News Feed data to our mobile apps, including RESTful server resources and FQL tables (Facebook&#x27;s SQL-like API). We were frustrated with the differences between the data we wanted to use in our apps and the server queries they required. We don&#x27;t think of data in terms of resource URLs, secondary keys, or join tables; we think about it in terms of a graph of objects and the models we ultimately use in our apps like NSObjects or JSON.</p><p>There was also a considerable amount of code to write on both the server to prepare the data and on the client to parse it. This frustration inspired a few of us to start the project that ultimately became GraphQL. GraphQL was our opportunity to rethink mobile app data-fetching from the perspective of product designers and developers. It moved the focus of development to the client apps, where designers and developers spend their time and attention.</p><h2><a class="anchor" name="what-is-graphql"></a>What is GraphQL? <a class="hash-link" href="/blog/graphql-a-query-language/#what-is-graphql">#</a></h2><p>A GraphQL query is a string that is sent to a server to be interpreted and fulfilled, which then returns JSON back to the client.</p><div><div id="r101"><div class="miniGraphiQL" data-reactid=".122w57y15hc" data-react-checksum="1706638477"><div class="query-editor" data-reactid=".122w57y15hc.0"></div><div class="result-window" data-reactid=".122w57y15hc.1"></div></div></div>

</div><p><strong>Defines a data shape:</strong> The first thing you&#x27;ll notice is that GraphQL queries mirror their response. This makes it easy to predict the shape of the data returned from a query, as well as to write a query if you know the data your app needs. More important, this makes GraphQL really easy to learn and use. GraphQL is unapologetically driven by the data requirements of products and of the designers and developers who build them.</p><p><strong>Hierarchical:</strong> Another important aspect of GraphQL is its hierarchical nature. GraphQL naturally follows relationships between objects, where a RESTful service may require multiple round-trips (resource-intensive on mobile networks) or a complex join statement in SQL. This data hierarchy pairs well with graph-structured data stores and ultimately with the hierarchical user interfaces it&#x27;s used within.</p><p><strong>Strongly typed:</strong> Each level of a GraphQL query corresponds to a particular type, and each type describes a set of available fields. Similar to SQL, this allows GraphQL to provide descriptive error messages before executing a query. It also plays well with the strongly typed native environments of Obj-C and Java.</p><p><strong>Protocol, not storage:</strong> Each GraphQL field on the server is backed by a function - code linking to your application layer. While we were building GraphQL to support News Feed, we already had a sophisticated feed ranking and storage model, along with existing databases and business logic. GraphQL had to leverage all this existing work to be useful, and so does not dictate or provide any backing storage. Instead, GraphQL takes advantage of your existing code by exposing your application layer, not your storage layer.</p><p><strong>Introspective:</strong> A GraphQL server can be queried for the types it supports. This creates a powerful platform for tools and client software to build atop this information like code generation in statically typed languages, our application framework, Relay, or IDEs like GraphiQL (pictured below). GraphiQL helps developers learn and explore an API quickly without grepping the codebase or wrangling with cURL.</p><div><div id="r102"><div class="miniGraphiQL" data-reactid=".1iveslwxybk" data-react-checksum="-1076870974"><div class="query-editor" data-reactid=".1iveslwxybk.0"></div><div class="result-window" data-reactid=".1iveslwxybk.1"></div></div></div>

</div><p><strong>Version free:</strong> The shape of the returned data is determined entirely by the client&#x27;s query, so servers become simpler and easy to generalize. When you&#x27;re adding new product features, additional fields can be added to the server, leaving existing clients unaffected. When you&#x27;re sunsetting older features, the corresponding server fields can be deprecated but continue to function. This gradual, backward-compatible process removes the need for an incrementing version number. We still support three years of released Facebook applications on a single version of our GraphQL API.</p><p>With GraphQL, we were able to build full-featured native News Feed on iOS in 2012, and on Android shortly after. Since then, GraphQL has become the primary way we build our mobile apps and the servers that power them. More than three years later, GraphQL powers almost all data-fetching in our mobile applications, serving millions of requests per second from nearly 1,000 shipped application versions.</p><p>When we built GraphQL in 2012 we had no idea how important it would become to how we build things at Facebook and didn&#x27;t anticipate its value beyond Facebook. However earlier this year we announced Relay, our application framework for the web and React Native built atop GraphQL. The community excitement for Relay inspired us to revisit GraphQL to evaluate every detail, make improvements, fix inconsistencies, and write a specification describing GraphQL and how it works.</p><p>Two months ago, we <a href="https://www.youtube.com/watch?v=WQLzZf34FJ8" target="_blank">made our progress public</a> and released a working draft of the <a href="http://facebook.github.io/graphql/" target="_blank">GraphQL spec</a> and a reference implementation: <a href="https://github.com/graphql/graphql-js" target="_blank">GraphQL.js</a>. Since then, a community has started to form around GraphQL, and versions of the GraphQL runtime are being <a href="https://github.com/chentsulin/awesome-graphql" target="_blank">built in many languages</a>, including Go, Ruby, Scala, Java, .Net, and Python. We&#x27;ve also begun to share some of the tools we use internally, like <a href="https://github.com/graphql/graphiql" target="_blank">GraphiQL</a>, an in-browser IDE, documentation browser, and query runner. GraphQL has also seen production usage outside Facebook, in a project for the <a href="https://www.youtube.com/watch?v=S0s935RKKB4" target="_blank"><em>Financial Times</em></a> by consultancy <a href="http://red-badger.com/" target="_blank">Red Badger</a>.</p><p>“GraphQL makes orchestrating data fetching so much simpler and it pretty much functions as a perfect isolation point between the front end and the back end”
— Viktor Charypar, software engineer at Red Badger</p><p>While GraphQL is an established part of building products at Facebook, its use beyond Facebook is just beginning. Try out <a href="http://graphql-swapi.parseapp.com/graphiql/" target="_blank">GraphiQL</a> and help provide feedback on our <a href="https://github.com/facebook/graphql/" target="_blank">specification</a>. We think GraphQL can greatly simplify data needs for both client product developers and server-side engineers, regardless of what languages you&#x27;re using in either environment, and we&#x27;re excited to continue to improve GraphQL, help a community grow around it, and see what we can build together.</p></div></div></section><footer class="wrap"><div class="right">©2015 Facebook Inc.</div></footer></div><div id="fb-root"></div><script>
            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
          </script><script src="//cdn.jsdelivr.net/react/0.13.3/react.js"></script><script src="index.html.bae6f960b0489ca8b3c2.js"></script></body></html>